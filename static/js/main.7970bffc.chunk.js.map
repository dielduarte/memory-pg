{"version":3,"sources":["state/iconsMap.js","state/services.js","state/actions.js","state/guards.js","state/index.js","components/IconsGrid.js","components/GameDisplay.js","components/UserPoints.js","App.js","serviceWorker.js","scripts/webfrontloader.js","index.js"],"names":["regularIcons","plusIcons","map","it","startsIcons","getRandomIcon","context","nextIcon","sample","IconsMap","currentSequence","includes","addRandomIcon","assign","addUserChoice","userSequence","event","payload","iconId","checkIfUserChoicesIsOver","userChoicesIsOver","length","sequenceCount","checkIfUserWon","userWon","isEqual","checkUserPoints","points","resetState","isCurrentSequenceUnfinished","isUserEnableToMakeChoice","Machine","id","initial","undefined","interval","icons","states","idle","on","START_ROUND","target","actions","meta","test","getByText","assert","ok","startRound","invoke","src","pipe","value","take","START","cond","stopRound","ADD_USER_CHOICE","RESTART","guards","Container","styled","div","IconContainer","button","props","active","IconsGrid","current","send","isIconActive","key","onClick","type","data-testid","className","TextAction","GameDisplay","iconClass","matches","handleStartRound","useCallback","handleRestart","renderStartAction","renderFeedbackText","UserPoints","GameDisplayContainer","App","useMachine","gameMachine","Boolean","window","location","hostname","match","WebFont","load","google","families","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7970bffc.chunk.js","sourcesContent":["const prefix = 'icon'\n\nconst regularIcons = [\n  `${prefix}-bottle-red`,\n  `${prefix}-bottle-blue`,\n  `${prefix}-bottle-green`,\n  `${prefix}-bottle-yellow`,\n]\n\nconst plusIcons = regularIcons.map((it) => it + '-plus')\nconst startsIcons = regularIcons.map((it) => it + '-stars')\n\nexport default [\n  ...regularIcons,\n  ...plusIcons,\n  ...startsIcons\n]","import {interval} from \"rxjs\";\nimport {map, take} from \"rxjs/operators\";\nimport { sample } from \"lodash\";\n\nimport IconsMap from './iconsMap'\n\nexport const getRandomIconByInterval = (context) =>\n  interval(context.interval).pipe(\n    map(value => ('START')),\n    take(context.sequenceCount)\n  )\n\nexport const getRandomIcon = (context) => {\n  const nextIcon = sample(IconsMap)\n  if(context.currentSequence.includes(nextIcon)) {\n    return getRandomIcon(context)\n  }\n\n  return nextIcon\n}","import { assign } from \"xstate\";\nimport { isEqual } from \"lodash\";\n\nimport { getRandomIcon } from './services'\n\nexport const addRandomIcon = assign({\n  currentSequence: context => [...context.currentSequence, getRandomIcon(context)]\n})\n\nexport const addUserChoice = assign({\n  userSequence: (context, event) => {\n    return [...context.userSequence, event.payload.iconId];\n  }\n})\n\nexport const checkIfUserChoicesIsOver = assign({\n  userChoicesIsOver: (context) => context.userSequence.length >= context.sequenceCount\n})\n\nexport const checkIfUserWon = assign({\n  userWon: (context) => context.userChoicesIsOver && isEqual(context.userSequence, context.currentSequence)\n})\n\nexport const checkUserPoints = assign({\n  points: (context) => context.userChoicesIsOver && context.userWon ? context.points + 10 : context.points\n})\n\nexport const resetState = assign({\n  userWon: false,\n  userSequence: [],\n  currentSequence: [],\n  userChoicesIsOver: false\n})\n","export const isCurrentSequenceUnfinished = (context) => {\n  return context.currentSequence.length < context.sequenceCount;\n}\n\nexport const isUserEnableToMakeChoice = (context) => {\n  return !context.userChoicesIsOver\n}\n","import {Machine} from 'xstate';\n\nimport * as actions from './actions'\nimport * as guards from './guards'\nimport { getRandomIconByInterval } from './services'\nimport icons from './iconsMap'\nimport { assert } from 'chai';\n\nexport default Machine(\n  {\n    id: 'memoryPg',\n    initial: 'idle',\n    context: {\n      points: 0,\n      currentSequence: [],\n      userSequence: [],\n      userWon: undefined,\n      userChoicesIsOver: false,\n      interval: 1000,\n      sequenceCount: 4,\n      icons\n    },\n    states: {\n      idle: {\n        on: {\n          START_ROUND: {\n            target: 'startRound',\n            actions: 'addRandomIcon'\n          }\n        },\n        meta: {\n          test: ({ getByText }) => {\n            assert.ok(getByText('START'))\n          }\n        }\n      },\n      startRound: {\n        invoke: {\n          src: getRandomIconByInterval,\n        },\n        on: {\n          START: [\n            {\n              target: '',\n              actions: 'addRandomIcon',\n              cond: 'isCurrentSequenceUnfinished'\n            },\n            { target: 'stopRound' }\n          ]\n        }\n      },\n      stopRound: {\n        on: {\n          ADD_USER_CHOICE: {\n            target: '',\n            actions: ['addUserChoice', 'checkIfUserChoicesIsOver', 'checkIfUserWon', 'checkUserPoints'],\n            cond: 'isUserEnableToMakeChoice'\n          },\n          RESTART: {\n            target: 'startRound',\n            actions: ['resetState', 'addRandomIcon']\n          }\n        }\n      }\n    }\n  },\n  {\n    actions,\n    guards\n  }\n);\n","import React from 'react'\nimport styled from 'styled-components'\n\nconst Container = styled.div`\n  display: flex;\n  flex-wrap: wrap;\n  flex: 1;\n  max-height: 174px;\n  padding: 0 10px;\n      \n  @media(min-width: 768px) {\n    max-height: 116px;  \n  }\n`\n\nconst IconContainer = styled.button`\n  border: 1px solid transparent;\n  width: calc(100% / 4);\n  min-width: 32px;\n  background: transparent;\n  outline: none;\n  border: none;\n  cursor: pointer;\n  height: 48px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: 5px 0;\n\n  &:hover { border: 1px solid #fff; } \n\n  ${props => props.active && `\n    border: 1px solid #fff;\n  `}\n    \n  @media(min-width: 768px) {\n    width: calc(100% / 6);\n  }\n`\n\n\nfunction IconsGrid({ current, send }) {\n  const { context } = current;\n\n  const handleAddUserChoice = (iconId) => () => send({ type: 'ADD_USER_CHOICE', payload: { iconId } })\n  const isIconActive = (it) => context.userSequence.includes(it)\n\n  return <Container>\n    {context.icons.map((it, key) => (\n      <IconContainer\n        key={key}\n        onClick={handleAddUserChoice(it)}\n        active={isIconActive(it)}\n        data-testid={it}\n      >\n        <i className={`icon ${it}`} />\n      </IconContainer>\n    ))}\n  </Container>\n}\n\nexport default IconsGrid","import React, { useCallback }  from 'react'\nimport styled from \"styled-components\";\n\nconst TextAction = styled.button`\n  font-size: 18px;\n  border: none;\n  outline: none;\n  cursor: pointer;\n  line-height: 1.5em;\n  text-transform: uppercase;\n  \n  @media(min-width: 768px) {\n    font-size: 22px;\n  }\n`\n\nfunction renderStartAction(handleStartRound) {\n  return <TextAction onClick={handleStartRound}>\n    START\n  </TextAction>\n}\n\nfunction renderYourTimeText() {\n  return <TextAction>\n    YOUR TIME\n  </TextAction>\n}\n\nfunction renderFeedbackText(userWon, handleRestart) {\n  return <TextAction onClick={handleRestart}>\n    {`${userWon ? 'You got it!': 'Not this time baby'}`}\n    <br />\n    restart\n  </TextAction>\n}\n\nfunction renderIcon(iconClass) {\n  return <i className={`icon ${iconClass}`}/>\n}\n\nfunction GameDisplay({ current, send }) {\n  const { context, matches } = current\n\n  const handleStartRound = useCallback(() => {\n    send('START_ROUND')\n  }, [send])\n\n  const handleRestart = useCallback(() => {\n    send('RESTART')\n  }, [send])\n\n\n  switch (true) {\n    case matches('idle'):\n      return renderStartAction(handleStartRound)\n    case context.userChoicesIsOver:\n      return renderFeedbackText(context.userWon, handleRestart)\n    case matches('stopRound'):\n      return renderYourTimeText()\n    default:\n      return renderIcon(context.currentSequence[context.currentSequence.length - 1])\n  }\n}\n\nexport default GameDisplay","import React from 'react'\nimport styled from \"styled-components\";\n\nconst Container = styled.div`\n  display: flex;\n  flex: 1;\n  min-height: 80px;\n  max-height: 80px;\n  justify-content: flex-end;\n  padding: 20px 10px;\n  align-items: center;\n  font-size: 18px;\n   \n  i { margin-right: 10px; }\n   \n  @media(min-width: 768px) {\n    font-size: 22px;\n  }\n`\n\n\nfunction UserPoints({ current }) {\n  return <Container>\n    <i className=\"menu-icon menu-icon-diamond\" />\n    {current.context.points}\n  </Container>;\n}\n\nexport default UserPoints","import React from 'react';\nimport { useMachine } from '@xstate/react';\nimport styled from \"styled-components\";\n\nimport gameMachine from './state/index'\nimport IconsGrid from \"./components/IconsGrid\";\nimport GameDisplay from \"./components/GameDisplay\";\nimport UserPoints from \"./components/UserPoints\";\n\nconst GameDisplayContainer = styled.div`\n  display: flex;\n  flex: 2;\n  justify-content: center;\n  align-items: center;\n`\n\n\nfunction App() {\n  const [current, send] = useMachine(gameMachine)\n\n  return (\n    <>\n      <UserPoints\n        current={current}\n        send={send}\n      />\n      <GameDisplayContainer>\n        <GameDisplay\n          current={current}\n          send={send}\n        />\n      </GameDisplayContainer>\n      <IconsGrid\n        current={current}\n        send={send}\n      />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import WebFont from 'webfontloader'\n\nWebFont.load({\n  google: {\n    families: ['Press Start 2P']\n  }\n});","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './scripts/webfrontloader'\nimport './styles/iconsMap-sprites.css'\nimport './styles/menu-icons-sprites.css'\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}